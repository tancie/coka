<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="/public/index.css">
    <!-- <link rel="stylesheet" href="/public/kinship.css"> -->

    <title>WEBGL-数据血缘图</title>
    <style>
        * {
            padding: 0;
            margin: 0
        }

        html,
        body,
        #threeBox {
            height: 100%;
            width: 100%
        }

        #threeBox {
            background: #000;
        }

        .pop-box {
            position: fixed;
            color: #5ecaea;
            background: #999;
            border-radius: 4px;
            padding: 8px;
            display: none;
        }

        .pop-box::after {
            content: "";
            height: 0;
            width: 0;
            border: 5px solid transparent;
            border-top: 10px solid #ffffff55;
            border-bottom: none;
            position: absolute;
            bottom: -10px;
            left: calc(50% - 5px);
        }

        .pop-box>div {
            margin: 4px 0;
            height: 24px;
        }

        .pop-box span {
            display: block;
            float: left
        }

        .pop-box>div>span:first-child {
            width: 82px
        }

        .pop-box>div>span:last-child {
            max-width: 270px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .select-node {
            width: 214px;
            font-size: 22px;
            position: absolute;
            top: 20px;
            left: 20px;
        }

        .show-type {
            color: #fff;
            position: absolute;
            right: 20px;
            top: 20px;
        }

        .select-node>input {
            background: #ccc;
            width: 206px;
            height: 20px;
            border-radius: 4px;
            border: none;
            padding: 4px 8px;
            color: rgba(0, 0, 0, .65);
        }

        .select-node>input:focus {
            border: none;
            outline: none;
        }

        .select-node>button {
            padding: 4px 8px;
            background: #108ee9;
            border: none;
            color: #fff;
            cursor: pointer;

        }

        .select-node>ul {
            display: none;
            width: 100%;
            background: #ccc;
            margin-top: 4px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 14px;
            padding: 4px;
        }

        .select-node>ul>li {
            color: #108ee9;
            padding: 4px;
            border-bottom: 1px dashed #fff;
            cursor: pointer;
        }

        .load {
            position: fixed;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;

            background: rgba(255, 255, 255, .3);
            color: #fff;
            font-size: 64px;
            z-index: 99;
        }

        #hawkEye {
            position: fixed;
            right: 10px;
            bottom: 10px;
            width: 500px;
            height: 250px;
        }
    </style>
</head>

<body>
    <div class="load" id="load">loading...</div>
    <div id="threeBox">
    </div>
    <div class="select-node">
        <input id="searchId" />
        <!-- <button id="searchBtn">查询</button> -->
        <ul id="searchList">


        </ul>
    </div>
    <div class="show-type">
        <form>
            <label>
                <input type="radio" name="showType" value="all" checked/> 所有表
            </label>
            <label>
                <input type="radio" name="showType" value="direct" /> 直接上下游表
            </label>
        </form>

    </div>
    <!-- <div id="hawkEye"> </div> -->
    <script>
        window.onload = () => { load.style.display = "none" }
    </script>
    <script src="/public/list.js"></script>
    <script src="/public/dagre.min.js"></script>
    <script src="/public/three.min.js"></script>
    <script src="/public/MapControls.js"></script>
    <script src="/public/table_array.js"></script>

    <script>
        let showType = 'all';
        let box = document.querySelector('.select-node')
        let radio = document.querySelectorAll('input[name=showType]')
        box.onmouseleave = () => {
            searchList.style.display = "none"
        }
        searchId.onclick = searchId.oninput = () => {
            searchList.style.display = "block"

            let id = searchId.value;
            // if (!id) {
            //     return;
            // }
            let reg = new RegExp(id);
            let li = ''
            datas.nodes.map((val) => {
                if (reg.test(val.name)) {
                    li += `<li data-id=${val.label}>
                            
                            ${val.name}
                           
                        </li>`
                }
            })

            searchList.innerHTML = li;

        }
        searchList.onclick = (e) => {
            if (e.target.tagName === 'LI') {
                let id = e.target.getAttribute('data-id');
                load.style.display = "flex";
                setTimeout(()=>getNodesData(id),5);
                searchList.style.display = "none";
            }
            // console.log(e)
        }
        [...radio].map((val) => {
            val.onclick = function (e) {
                showType = e.target.value;
                rerender()
            }
        })

    </script>

    <script>
        let g = new dagre.graphlib.Graph();
        let getAncestorNodes = (list, id, direction) => {
            direction = direction || 'up';

            if (!list[id]) {
                console.info(`no ${id}`)
                return;
            }

            let data = { nodes: [Object.assign({ nodeType: 'main' }, list[id])], edges: [] };
            let leafPath = {};
            let nodesIndex = [id];
            let edgeIndexs = [];

            let addParentRelationships = (key, findPath, findNode, currentPath) => {

                let current = list[key];
                if (!current) {
                    return;
                }
                let nexts = direction === 'down' ? current.children : current.parents;
                // nexts.map((val)=>{
                //     data.edges.push({ source: current.id, target: val });
                //     data.nodes.push(list[val]);

                // })
                // return {data}
                if (nexts.length > 0) {
                    nexts.forEach(nextKey => {

                        let childCurrentPath = currentPath + "|" + nextKey
                        let childFindNode = findNode
                        let childFindPath = findPath

                        if (childFindNode) {
                            let source = nextKey;
                            let target = key;
                            if (source === target) {
                                childFindNode = false
                                // return
                            } else {
                                if (direction === 'down') {
                                    source = key;
                                    target = nextKey;
                                }

                                let edgeIndex = `${source}-${target}`;

                                if (!edgeIndexs.includes(edgeIndex) && source in list && target in list) {
                                    data.edges.push({ source: source, target: target });
                                    edgeIndexs.push(edgeIndex);
                                }

                                if (!nodesIndex.includes(nextKey)) {
                                    if (!list[nextKey]) {
                                        childFindNode = false
                                        // return
                                    } else {
                                        data.nodes.push(Object.assign({ nodeType: direction }, list[nextKey]));
                                        nodesIndex.push(nextKey);
                                    }
                                } else {
                                    childFindNode = false
                                }
                            }
                        }

                        if (childFindPath) {
                            let pathArr = currentPath.split('|')
                            let index = pathArr.indexOf(nextKey)
                            if (index < 0) {

                            } else if (index !== pathArr.length - 1) {
                                childFindPath = false
                                if (leafPath[nextKey]) {
                                    leafPath[nextKey].push(currentPath)
                                } else {
                                    leafPath[nextKey] = [currentPath]
                                }
                            } else {
                                childFindPath = false
                            }
                        }

                        if (childFindNode || childFindPath) {
                            addParentRelationships(nextKey, childFindPath, childFindNode, childCurrentPath);
                        }

                    });
                } else {
                    if (leafPath[key]) {
                        leafPath[key].push(currentPath)
                    } else {
                        leafPath[key] = [currentPath]
                    }
                }
            }

            let getLeafPath = (key, currentPath) => {

                let current = list[key];
                if (!current) {
                    return;
                }
                let nexts = direction === 'down' ? current.children : current.parents;
                if (nexts.length > 0) {
                    nexts.forEach(nextKey => {
                        let childCurrentPath = currentPath + "|" + nextKey
                        let pathArr = currentPath.split('|')
                        let index = pathArr.indexOf(nextKey)
                        if (index < 0) {
                            getLeafPath(nextKey, childCurrentPath);
                        } else if (index !== pathArr.length - 1) {
                            if (leafPath[nextKey]) {
                                leafPath[nextKey].push(currentPath)
                            } else {
                                leafPath[nextKey] = [currentPath]
                            }
                        }

                    });
                } else {
                    if (leafPath[key]) {
                        leafPath[key].push(currentPath)
                    } else {
                        leafPath[key] = [currentPath]
                    }
                }
            }

            let rootPath = id

            addParentRelationships(id, true, true, rootPath);
            getLeafPath(id, rootPath);

            nodesIndex = undefined;

            return { data, leafPath };
        }
        let list = {}
        data.map((val) => {
            list[val.id] = val;
        })
        // fs.writeFile('./list.js','const list = '+JSON.stringify(list),(err)=>{console.log(err)});

        let keys = Object.keys(list)
        let len = keys.length
        let initRelaData = (nodes, edges) => {


            // Set an object for the graph label
            g.setGraph({
                rankdir: 'RL',
                // nodesep: 50,
                ranksep: 200,
                // edgesep: 20
            });

            // Default to assigning a new object as a label for each new edge.
            g.setDefaultEdgeLabel(function () { return {}; });
            console.time('loop')
            let fontSize = 24
            nodes.map((val, idx) => {
                let width = val.name.length * fontSize + 10; //5+5 //左右pading
                g.setNode(val.id, {
                    label: val.name,
                    width,
                    height: 64,
                    nodeType: val.nodeType,
                    name: val.cname,
                    parents: val.parents,
                    children: val.children
                });

            })
            edges.map((val, idx) => {
                g.setEdge(val.source, val.target);
            })
            console.timeEnd('loop')
            console.time('layout')
            dagre.layout(g);
            console.timeEnd('layout')

            // console.log(g)
        }

        let getReladata = (id = 'dw_housedel_housedel_all_info_branch_da') => {
            let ALLUP = getAncestorNodes(list, id, 'up')

            let ALLDOWN = getAncestorNodes(list, id, 'down')

            console.log(ALLUP, ALLDOWN)

            let nodes = ALLUP.data.nodes.concat(ALLDOWN.data.nodes);
            let edges = ALLUP.data.edges.concat(ALLDOWN.data.edges);
            console.log(edges.filter((edge) => {
                return edge.source === 'anti_dw_db_agent_risk_control_del_house_info_da' && edge.target === 'dw_housedel_housedel_all_info_da'
            }))

            initRelaData(nodes, edges);

            let datas = {
                nodes: [],
                edges: [],
                edgesId: edges,
                center: {
                    centerX: 0,
                    centerY: 0
                }
            }


            g.nodes().forEach(function (v) {
                let node = g.node(v);
                if (node.label === id) {
                    datas.center = {
                        centerX: 0 - node.x,
                        centerY: 0 - node.y
                    }
                    datas.main = node
                }
                datas.nodes.push(node);
            });
            g.edges().forEach(function (e) {
                datas.edges.push(Object.assign(g.edge(e), e));
            });
            //console.log('_________________',datas.nodes )
            return datas
        }
        let datas = getReladata()//keys[parseInt(Math.random() * len)])

    </script>


    <script>
        let popBox = document.createElement('div')
        popBox.className = "pop-box"
        document.body.appendChild(popBox)

        let directNode = [];



        //
        console.time('render')
        var container, stats;
        var camera, camera1, scene, raycaster, renderer, hawkRenderer, parentTransform, sphereInter, particles;
        var mouseX = 0, mouseY = 0;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var vertices = [];
        var mouse = new THREE.Vector2()
        var targetCenter = null;

        let { centerX, centerY } = datas.center;//datas.nodes[0].x/2





        initScene();
        // initHawk();
        drawCenterBox();
        drawLine();
        drawNode();

        animate();


        console.timeEnd('render')
        function initHawk() {
            hawkRenderer = new THREE.WebGLRenderer({ antialias: true });

            hawkRenderer.setSize(600, 350);
            hawkEye.appendChild(hawkRenderer.domElement);

        }
        function initScene() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            threeBox.appendChild(renderer.domElement);

            threeBox.addEventListener('mousemove', onDocumentMove, false);
            threeBox.addEventListener('dblclick', onDocumentDbClick, false);
            threeBox.addEventListener('click', onDocumentClick, false);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000000);
            camera.position.set(0, 0, 2000);
            camera.lookAt(0, 0, 0);

            camera1 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000000);
            camera1.position.set(0, 0, 20000);
            camera1.lookAt(0, 0, 0);


            //
            controls = new THREE.MapControls(camera, renderer.domElement);

            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            controls.screenSpacePanning = true;

            controls.minDistance = 100;
            // controls.maxDistance = 500;

            controls.maxPolarAngle = Math.PI / 2;

            scene = new THREE.Scene();
            var light = new THREE.DirectionalLight(0xffffff, 1.5, 100);
            light.position.set(0, 0, 1000);
            scene.add(light);

            var geometry = new THREE.BoxBufferGeometry(20, 20, 0);


        }

        function drawNode(adjacent) {
            let isDirect = showType === 'direct';

            color = '#0adc8b';
            if (!directNode.length) {
                directNode.push(datas.main.label)
            }

            var sprite = new THREE.Sprite( new THREE.SpriteMaterial( { color: 'red' } ) );
			sprite.position.set( 0, 0, 10 );
            sprite.scale.set( 20, 50, 10 );
            

            datas.nodes.map((val) => {
                let direct = val.children.concat(val.parents)
                if (isDirect) {
                    if (!(direct.find((v) => directNode.indexOf(v) > -1) || directNode.indexOf(val.label) > -1)) {
                        return
                    }
                   
                }

                let geometry = new THREE.BoxGeometry(val.width, val.height, 0);

                geometry.name = val.label;//id
                geometry.cname = val.name; //中文

                //选中点的相邻颜色
                if (adjacent && adjacent.indexOf(val.label) > -1) {
                    color = '#5b18ce'
                };

                //选中点的颜色
                if (adjacent && adjacent[0] == val.label) {
                    color = 'red'

                    camera.position.set(val.x + centerX, val.y + centerY, 2000);  //
                    controls.target.set(val.x + centerX, val.y + centerY, 0);

                };

                //默认查询的id颜色
                if (val.label === datas.main.label) {
                    color = 'yellow'
                }
                let texture = drawText(val, color);
                color = '#0adc8b'
                var object = new THREE.Mesh(geometry, texture);

                object.position.x = val.x + centerX;
                object.position.y = val.y + centerY;
                object.position.z = 0;

                scene.add(object);

            })

        }

        function drawLine() {
            var material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 5, // in pixels

                //vertexColors: THREE.VertexColors,
                //resolution:  // to be set by renderer, eventually
                dashed: false
            });
            let isDirect = showType === 'direct'
            datas.edges.map((val) => {
                if (isDirect) {
                    if (!(directNode.indexOf(val.v) > -1 || directNode.indexOf(val.w) > -1)) {
                        return
                    }
                    console.log('eeee')
                }

                let pos = val.points
                var geometry = new THREE.Geometry();
                pos.map((v) => {
                    geometry.vertices.push(new THREE.Vector3(v.x + centerX, v.y + centerY, 0));
                })


                let len = pos.length

                let source = {
                    position: {
                        x: pos[len - 2].x + centerX,
                        y: pos[len - 2].y + centerY,
                        z: 0
                    }
                }
                let target = {
                    position: {
                        x: pos[len - 1].x + centerX,
                        y: pos[len - 1].y + centerY,
                        z: 0
                    }
                }

                var direction = new THREE.Vector3();
                direction.subVectors(target.position, source.position)
                direction.normalize()
                var end = new THREE.Vector3(target.position.x, target.position.y, target.position.z)
                var start = new THREE.Vector3(source.position.x, source.position.y, source.position.z);
                var length = end.distanceTo(start);
                var arrowHelper = new THREE.ArrowHelper(direction, start, length, 0xcccccc, 16, 16);
                scene.add(arrowHelper)




                var line = new THREE.Line(geometry, material);
                // line.scale.set(2,2,2)
                scene.add(line);
            })



        }

        function drawCenterBox() {
            var geometry = new THREE.BoxBufferGeometry(512 * 2, 512 * 2, 0);
            targetCenter = new THREE.Mesh(geometry, drawText({ width: 256, height: 64, label: '' }, 'red'))//new THREE.MeshLambertMaterial({ color: 'red',wireframe:true }));

            scene.add(targetCenter);
            console.log(targetCenter)

        }
        function getPixelRatio(context) {
            var backingStore = context.backingStorePixelRatio ||
                context.webkitBackingStorePixelRatio ||
                context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio ||
                context.oBackingStorePixelRatio ||
                context.backingStorePixelRatio || 1;
            return (window.devicePixelRatio || 1) / backingStore;
        };

        function drawText(val, color = '#0adc8b') {
            let text = val.label
            var imageCanvas = document.createElement("canvas"),
                context = imageCanvas.getContext("2d");
            var ratio = 1//getPixelRatio(context);
            imageCanvas.width = val.width * ratio;
            imageCanvas.height = val.height * ratio;
            context.scale(ratio, ratio);

            context.fillStyle = color;
            context.textBaseline = "top";
            context.font = "48px Times New Roman"
            // context.strokeRect( 0, 0, 128, 128 );
            text.split('').map((t, i) => {
                context.fillText(t, 5 + i * 24 * ratio, 5 * ratio)
            })

            context.strokeStyle = color;

            context.strokeRect(0, 0, val.width, val.height);

            var textureCanvas = new THREE.CanvasTexture(imageCanvas);



            var materialCanvas = new THREE.MeshBasicMaterial({ map: textureCanvas });
            //materialCanvas.scale.set(2,2,2)
            return materialCanvas


        }
        function animate() {

            requestAnimationFrame(animate);

            render();
            // stats.update();

        }

        function render() {

            controls.update();
            // console.log(controls.target)
            targetCenter.visible = false;
            renderer.render(scene, camera);

            // targetCenter.visible = true;
            // targetCenter.position.set(controls.target.x, controls.target.y, controls.target.z);
            // hawkRenderer.render(scene, camera1)



        }
        function rerender() {
            scene.children = [];
            centerX = datas.center.centerX;
            centerY = datas.center.centerY;
            drawLine();
            drawNode();

            load.style.display = 'none';
            console.timeEnd('rerender')
        }



        var raycaster = new THREE.Raycaster();
        let INTERSECTED = null
        function onDocumentMove(event) {


            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {

                INTERSECTED = intersects[0].object;
                if (INTERSECTED.type === 'Mesh') {
                    let id = INTERSECTED.geometry.name
                    let detail = lists[id];
                    if (!detail) {
                        return
                    }

                    let popHTML = `
                        <div>
                            <span>中文名：</span>
                            <span>${detail.cname}</span>
                        </div>
                        <div><span>表名：</span><span>${detail.name}</span></div>
                        <div><span>创建人：</span><span>${detail.creator}</span></div>
                       
                        <div><span>描述：</span><span>${detail.description}</span></div>
                        <div><span>上游节点：</span><span>${detail.ups}</span></div>
                        <div><span>下游节点：</span><span>${detail.downs}</span></div>
                        `
                    popBox.innerHTML = popHTML;
                    popBox.style.display = "block";
                    let { clientWidth, clientHeight } = popBox;

                    popBox.style.top = `${event.clientY - clientHeight - 30}px`;
                    popBox.style.left = `${event.clientX - clientWidth / 2}px`


                }

            } else {

                INTERSECTED = null;
                popBox.style.display = "none";
            }



        }
        function onDocumentClick(event) {
            let isDirect = showType === 'direct';

            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {

                INTERSECTED = intersects[0].object;

                if (INTERSECTED.type === 'Mesh') {
                    let id = INTERSECTED.geometry.name

                    //如果只展示上下游
                    if (isDirect) {
                        let i = directNode.indexOf(id)
                        i > -1 ?
                            directNode.splice(i, 1)
                            :
                            directNode.push(id)
                        return rerender();


                    }

                    //如果在全部表中展示，则高亮
                    selectNode(id)

                }

            } else {

                INTERSECTED = null;
                popBox.style.display = "none";
            }



        }

        function onDocumentDbClick(event) {


            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {

                INTERSECTED = intersects[0].object;
                if (INTERSECTED.type === 'Mesh') {
                    let id = INTERSECTED.geometry.name

                    getNodesData(id);


                }

            }



        }

        function getNodesData(id) {
            load.style.display = 'flex';
            datas = getReladata(id)
            controls.reset();
            rerender();
            return

            // var xhr = new XMLHttpRequest();

            // xhr.onreadystatechange = function(){
            //     if(xhr.readyState == 4){
            //         if(xhr.status == 200){
            //             //实际操作
            //             console.time('rerender')
            //             let data = xhr.responseText
            //             datas = JSON.parse(data);


            //         }
            //     }
            // }
            // //发送请求
            // xhr.open('get','/rela?id='+id,true);
            // xhr.send();
        }

        function selectNode(id) {
            let adjacent = [id];
            adjacent = adjacent.concat(list[id].parents).concat(list[id].children)
            // datas.edgesId.map((val) => {
            //     if (val.source === id) {
            //         adjacent.push(val.target)
            //     } else if (val.target === id) {
            //         adjacent.push(val.source)
            //     }

            // })
            drawNode(adjacent)
        }



    </script>
</body>

</html>