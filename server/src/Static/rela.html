<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <!-- <link rel="stylesheet" href="/public/index.css"> -->
    <!-- <link rel="stylesheet" href="/public/kinship.css"> -->

    <title>WEBGL-数据血缘图</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }

        html,
        body,
        #threeBox {
            height: 100%;
            width: 100%
        }

        #threeBox {
            background: #000;
        }

        .pop-box {
            position: fixed;
            color: #fff;
            background: rgba(0, 0, 0, .5);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            display: none;
        }

        .pop-box::after {
            content: "";
            height: 0;
            width: 0;
            border: 5px solid transparent;
            border-top: 10px solid #ffffff;
            border-bottom: none;
            position: absolute;
            bottom: -10px;
            left: calc(50% - 5px);
        }

        .pop-box>div {
            margin: 4px 0;
            min-height: 24px;
        }

        .pop-box span {
            display: block;
            float: left
        }

        .pop-box>div>span:first-child {
            width: 82px
        }

        .pop-box>div>span:last-child {
            max-width: 270px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .select-node {
            width: 214px;
            font-size: 22px;
            float: left;
            flex: 1;
            position: relative;
        }

        #tableName {
            flex: 1;
            color: #fff;
            text-align: center;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            background: rgba(0, 0, 0, .5)
        }

        .show-type {
            color: #fff;
            text-align: right;
            flex: 1
        }

        .select-node>input {
            background: #ccc;
            width: 214px;
            height: 28px;
            border-radius: 4px;
            border: none;
            padding: 4px 8px;
            color: rgba(0, 0, 0, .65);
        }

        .select-node>input:focus {
            border: none;
            outline: none;
        }

        .select-node>button {
            padding: 4px 8px;
            background: #108ee9;
            border: none;
            color: #fff;
            cursor: pointer;

        }

        .select-node>ul {
            display: none;
            width: 100%;
            background: #c7c7c7;
            margin-top: 1px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 14px;
            padding: 4px;
            position: absolute;
            width: 214px;
        }

        .select-node>ul>li {
            color: rgba(0, 0, 0, .5);
            padding: 4px;
            border-bottom: 1px dashed #fff;
            cursor: pointer;
            white-space: nowrap;
        }

        .load {
            position: fixed;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            background: rgba(0, 0, 0, .8);
            color: #fff;
            font-size: 18px;
            z-index: 99;
        }

        .load>span {
            padding: 4px 8px;
            border: 1px solid #108ee9;
            border-radius: 4px;
        }

        #hawkEye {
            position: fixed;
            right: 10px;
            bottom: 10px;
            width: 500px;
            height: 250px;
        }

        #clickPath {
            color: #fff;
            position: fixed;
            width: 100%;
            padding: 0 50px;
            bottom: 20px;
            background: rgba(0, 0, 0, .8)
            /* display: flex; */
        }

        #clickPath>li {
            max-width: 20%;
            padding: 4px;
            float: left;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            color: #108ee9;
            border: 1px solid;
            margin: 0 4px;
            border-radius: 4px;
            cursor: pointer;

        }

        #clickPath>li:first-child {
            color: #fff;
            border: none;
        }
    </style>
</head>

<body>
    <div class="load" id="load">
        <span>loading...</span>
    </div>
    <div id="threeBox">
    </div>
    <div style="position: absolute;padding:20px 20px 0;top:0;width: 100%;
    line-height: 28px;display: flex;justify-content: center;z-index: 999;background: rgba(0,0,0,.8)">


        <div class="select-node">
            <input id="searchId" />
            <!-- <button id="searchBtn">查询</button> -->
            <ul id="searchList">


            </ul>
        </div>
        <h1 id="tableName"></h1>
        <div class="show-type">
            <form>
                <label>
                    <input type="radio" name="showType" value="all" checked/> 所有上下游表
                </label>
                <label>
                    <input type="radio" name="showType" value="direct" /> 直接上下游表
                </label>
            </form>

        </div>
    </div>
    <ul id="clickPath">

    </ul>
    <!-- <div id="hawkEye"> </div> -->
    <script>
        window.onload = () => { load.style.display = "none" }
        function ajax(url, callback) {
            var xhr = new XMLHttpRequest();

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        //实际操作
                        console.time('rerender')
                        let data = xhr.responseText
                        data = JSON.parse(data);
                        callback(data);



                    }
                }
            }
            //发送请求
            xhr.open('get', 'http://beta.mp.lianjia.com:8899' + url, false);
            xhr.send();
        }
    </script>
    <script src="./list.js"></script>
    <script src="./dagre.min.js"></script>
    <script src="./three.min.js"></script>
    <script src="./MapControls.js"></script>
    <script src="./table_array.js"></script>

    <script>
        let showType = 'all';
        let box = document.querySelector('.select-node')
        let radio = document.querySelectorAll('input[name=showType]')
        box.onmouseleave = () => {
            searchList.style.display = "none"
        }
        ajax('/list', (data) => window.listData = data.data);
        searchId.onclick = searchId.oninput = () => {
            searchList.style.display = "block"

            let id = searchId.value;
            // if (!id) {
            //     return;
            // }
            let reg = new RegExp(id);
            let li = ''
            let counter = 0
            window.listData.map((v) => {
                if (counter > 100) {
                    return;
                }
                let val = list[v.id]

                if (reg.test(val.cname) || reg.test(val.name)) {
                    let detail = val
                    li += `<li data-id=${val.id} title=${detail.description}>
                            
                            <p>${val.cname}</p>
                            <p>${val.id}</p>
                            <p style="color:#108ee9">上下游表：${detail.ups}/${detail.downs}</p>
                            
                
                           
                        </li>`
                    counter++
                }
            })

            searchList.innerHTML = li;

        }
        searchList.onclick = (e) => {
            if (e.target.tagName === 'LI' || e.target.parentNode.tagName === 'LI') {
                let id = e.target.getAttribute('data-id') || e.target.parentNode.getAttribute('data-id');
                load.style.display = "flex";
                setTimeout(() => {
                    if (showType === 'direct') {
                        directNode = [id];
                        return getDirectNode(id);
                    }
                    getNodesData(id)
                }, 5);
                searchList.style.display = "none";
            }
            // console.log(e)
        }
        [...radio].map((val) => {
            val.onclick = function (e) {
                showType = e.target.value;
                if (showType === 'direct') {
                    directNode = [datas.main.label]
                    clickPath.style.display = "block"
                    getDirectNode();


                } else {
                    getNodesData(directNode.pop())
                    clickPath.style.display = "none"
                }
               
            }
        })

        clickPath.onclick = (e) => {
            let tag = e.target
            let id = tag.getAttribute('data-id');
            if (tag.tagName === "LI" && id) {

                let i = directNode.indexOf(id)
                i > -1 && directNode.splice(i, 1)

                directNode.push(id);
                getDirectNode();
            }
        }

    </script>

    <script>
        window.datas = null, g = null;

        let getAncestorNodes = (list, id, direction) => {
            direction = direction || 'up';

            if (!list[id]) {
                console.info(`no ${id}`)
                return;
            }

            let data = { nodes: [Object.assign({ nodeType: 'main' }, list[id])], edges: [] };
            let leafPath = {};
            let nodesIndex = [id];
            let edgeIndexs = [];

            let addParentRelationships = (key, findPath, findNode, currentPath) => {

                let current = list[key];
                if (!current) {
                    return;
                }
                let nexts = direction === 'down' ? current.children : current.parents;
                // nexts.map((val)=>{
                //     data.edges.push({ source: current.id, target: val });
                //     data.nodes.push(list[val]);

                // })
                // return {data}
                if (nexts.length > 0) {
                    nexts.forEach(nextKey => {

                        let childCurrentPath = currentPath + "|" + nextKey
                        let childFindNode = findNode
                        let childFindPath = findPath

                        if (childFindNode) {
                            let source = nextKey;
                            let target = key;
                            if (source === target) {
                                childFindNode = false
                                // return
                            } else {
                                if (direction === 'down') {
                                    source = key;
                                    target = nextKey;
                                }

                                let edgeIndex = `${source}-${target}`;

                                if (!edgeIndexs.includes(edgeIndex) && source in list && target in list) {
                                    data.edges.push({ source: source, target: target });
                                    edgeIndexs.push(edgeIndex);
                                }

                                if (!nodesIndex.includes(nextKey)) {
                                    if (!list[nextKey]) {
                                        childFindNode = false
                                        // return
                                    } else {
                                        data.nodes.push(Object.assign({ nodeType: direction }, list[nextKey]));
                                        nodesIndex.push(nextKey);
                                    }
                                } else {
                                    childFindNode = false
                                }
                            }
                        }

                        if (childFindPath) {
                            let pathArr = currentPath.split('|')
                            let index = pathArr.indexOf(nextKey)
                            if (index < 0) {

                            } else if (index !== pathArr.length - 1) {
                                childFindPath = false
                                if (leafPath[nextKey]) {
                                    leafPath[nextKey].push(currentPath)
                                } else {
                                    leafPath[nextKey] = [currentPath]
                                }
                            } else {
                                childFindPath = false
                            }
                        }

                        if (childFindNode || childFindPath) {
                            addParentRelationships(nextKey, childFindPath, childFindNode, childCurrentPath);
                        }

                    });
                } else {
                    if (leafPath[key]) {
                        leafPath[key].push(currentPath)
                    } else {
                        leafPath[key] = [currentPath]
                    }
                }
            }

            let getLeafPath = (key, currentPath) => {

                let current = list[key];
                if (!current) {
                    return;
                }
                let nexts = direction === 'down' ? current.children : current.parents;
                if (nexts.length > 0) {
                    nexts.forEach(nextKey => {
                        let childCurrentPath = currentPath + "|" + nextKey
                        let pathArr = currentPath.split('|')
                        let index = pathArr.indexOf(nextKey)
                        if (index < 0) {
                            getLeafPath(nextKey, childCurrentPath);
                        } else if (index !== pathArr.length - 1) {
                            if (leafPath[nextKey]) {
                                leafPath[nextKey].push(currentPath)
                            } else {
                                leafPath[nextKey] = [currentPath]
                            }
                        }

                    });
                } else {
                    if (leafPath[key]) {
                        leafPath[key].push(currentPath)
                    } else {
                        leafPath[key] = [currentPath]
                    }
                }
            }

            let rootPath = id

            addParentRelationships(id, true, true, rootPath);
            getLeafPath(id, rootPath);

            nodesIndex = undefined;

            return { data, leafPath };
        }
        let list = {}
        data.map((val) => {
            list[val.id] = val;
        })

        let keys = Object.keys(list)
        let len = keys.length
        let initRelaData = (nodes, edges) => {
            g = new dagre.graphlib.Graph();

            g.setGraph({
                rankdir: 'RL',
                // nodesep: 50,
                ranksep: 200,
                // edgesep: 20
            });

            // Default to assigning a new object as a label for each new edge.
            g.setDefaultEdgeLabel(function () { return {}; });
            console.time('loop')
            let fontSize = 24
            nodes.map((val, idx) => {
                let width = val.name.length * fontSize + 10; //5+5 //左右pading
                g.setNode(val.id, {
                    label: val.name,
                    width,
                    height: 64,
                    nodeType: val.nodeType,
                    name: val.cname,
                    parents: val.parents,
                    children: val.children
                });

            })
            edges.map((val, idx) => {
                g.setEdge(val.source, val.target);
            })
            console.timeEnd('loop')
            console.time('layout')
            dagre.layout(g);
            console.timeEnd('layout')

            // console.log(g)
        }

        let getReladata = (id = 'dw_housedel_housedel_all_info_branch_da') => {
            load.style.display = 'flex'
            let ALLUP = getAncestorNodes(list, id, 'up')

            let ALLDOWN = getAncestorNodes(list, id, 'down')

            console.log(ALLUP, ALLDOWN)

            let nodes = ALLUP.data.nodes.concat(ALLDOWN.data.nodes);
            let edges = ALLUP.data.edges.concat(ALLDOWN.data.edges);
            console.log(edges.filter((edge) => {
                return edge.source === 'anti_dw_db_agent_risk_control_del_house_info_da' && edge.target === 'dw_housedel_housedel_all_info_da'
            }))

            productionDatas(nodes, edges, id)
            //console.log('_________________',datas.nodes )
            return datas
        }
        // getReladata()//keys[parseInt(Math.random() * len)])
        function productionDatas(nodes, edges, mid) {
            initRelaData(nodes, edges);

            datas = {
                nodes: [],
                edges: [],
                edgesId: edges,
                center: {
                    centerX: 0,
                    centerY: 0
                }
            }


            g.nodes().forEach(function (v) {
                let node = g.node(v);
                if (node.label === mid) {
                    datas.center = {
                        centerX: 0 - node.x,
                        centerY: 0 - node.y
                    }
                    centerX = 0 - node.x;
                    centerY = 0 - node.y;
                    datas.main = node
                }
                datas.nodes.push(node);
            });
            g.edges().forEach(function (e) {
                datas.edges.push(Object.assign(g.edge(e), e));
            });

            //


        }
        function getDirectNode() {
            let nodes = [], edges = [];
            let main = null;
            let li = '';
            // directNode.map((id) => {
            let getIdNode = (id) => {
                main = lists[id];
                let cNode = main.children//.concat(main.parents);
                let pNode = main.parents;
                cNode.map((cid) => {
                    nodes.push(lists[cid]);
                    edges.push({ target: cid, source: id })
                })
                pNode.map((pid) => {
                    nodes.push(lists[pid]);
                    edges.push({ source: pid, target: id })
                })
                nodes.push(main);



            }
            // )
            getIdNode(directNode[directNode.length - 1]);
            for(let i=0;i<5;i++){
                let id = directNode[i]
                li = `
                <li title=${id} data-id=${id}>${id}</li>
                `+ li
            }
            
            li = '<li>历史点击：</li>' + li;
            clickPath.innerHTML = li;
            productionDatas(nodes, edges, directNode[directNode.length - 1])
            rerender();


        }
        ajax('/rela?id=dw_housedel_housedel_all_info_branch_da', (data) => { datas = data.data })
    </script>


    <script>
        let popBox = document.createElement('div')
        popBox.className = "pop-box"
        document.body.appendChild(popBox)

        let popClickBox = document.createElement('div')
        popClickBox.className = "pop-box"
        document.body.appendChild(popClickBox)
        let clickId = null;

        let directNode = [];

        //

        var imageCanvas = document.createElement("canvas")

        console.time('word')
        drawWord();
        console.timeEnd('word')



        //
        console.time('render')
        var container, stats;
        var camera, camera1, scene, raycaster, renderer, hawkRenderer, parentTransform, sphereInter, particles;
        var mouseX = 0, mouseY = 0;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var vertices = [];
        var mouse = new THREE.Vector2()
        var targetCenter = null;
        let FONT = null;

        let { centerX, centerY } = datas.center;//datas.nodes[0].x/2





        initScene();
        // initHawk();
        // drawCenterBox();
        drawLine();
        drawNode();

        animate();


        console.timeEnd('render')
        function initHawk() {
            hawkRenderer = new THREE.WebGLRenderer({ antialias: true });

            hawkRenderer.setSize(600, 350);
            hawkEye.appendChild(hawkRenderer.domElement);

        }
        function initScene() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            threeBox.appendChild(renderer.domElement);

            threeBox.addEventListener('mousemove', onDocumentMove, false);
            // threeBox.addEventListener('dblclick', onDocumentDbClick, false);
            threeBox.addEventListener('click', onDocumentClick, false);
            threeBox.addEventListener('mousedown', () => popClickBox.style.display = "none", false);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000000);
            camera.position.set(0, 0, 5000);
            camera.lookAt(0, 0, 0);

            camera1 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000000);
            camera1.position.set(0, 0, 20000);
            camera1.lookAt(0, 0, 0);


            //
            controls = new THREE.MapControls(camera, renderer.domElement);

            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            controls.screenSpacePanning = true;

            controls.minDistance = 100;
            // controls.maxDistance = 500;

            controls.maxPolarAngle = Math.PI / 2;

            scene = new THREE.Scene();
            // var light = new THREE.DirectionalLight(0xffffff, 40, 100);
            // light.position.set(0, 0, 1000);
            // scene.add(light);

            var geometry = new THREE.BoxBufferGeometry(20, 20, 0);


        }

        function drawNode(adjacent) {
            tableName.innerHTML = datas.main.name
            tableName.title = datas.main.name
            // let isDirect = showType === 'direct';


            // if (isDirect && !directNode.length) {
            //     directNode.push(datas.main.label)
            // }

            // var sprite = new THREE.Sprite(new THREE.SpriteMaterial({ color: 'red' }));
            // sprite.position.set(0, 0, 10);
            // sprite.scale.set(20, 50, 10);
            var loader = new THREE.FontLoader();
            FONT ?
                dataMapNode()
                :
                loader.load('./helvetiker_regular.typeface.json', function (font) {
                    FONT = font;
                    dataMapNode()
                });

            //绿色 #61f316
            //黄色 #e8e756
            //紫色 #8756d5
            //红色 #d73143
            function dataMapNode() {

                datas.nodes.map((val) => {
                    color = '#24f705';
                    // let direct = val.children.concat(val.parents)
                    // if (isDirect) {
                    //     if (!(direct.find((v) => directNode.indexOf(v) > -1) || directNode.indexOf(val.label) > -1)) {
                    //         return
                    //     }

                    // }

                    let geometry = new THREE.BoxGeometry(val.width, val.height, 0);

                    geometry.name = val.label;//id
                    geometry.cname = val.name; //中文



                    //选中点的颜色 紫色
                    // if (adjacent&&adjacent.label === val.label) {
                    //     color = '#8756d5';
                    // };


                    //直接上下游的选中路径
                    // if (
                    //     showType === 'direct'
                    //     && directNode.indexOf(val.label) > -1
                    //     && directNode[drawNode.length - 1] !== val.label) {
                    //     color = '#d73143'
                    // }

                    //默认查询的id颜色
                    if (val.label === datas.main.label) {
                        color = '#e8e756'
                    }


                    //


                    // return addLabel(val.name,{x:val.x + centerX-val.width/2,y:val.y + centerY},color)

                    // 手动绘制文字
                    let texture = drawTextBorder(val, color);
                    // texture.selected = !!adjacent;

                    var object = new THREE.Mesh(geometry, texture)//,new THREE.MeshBasicMaterial({ color:'rgba(255,255,255,0)' }))//, texture);

                    object.position.x = val.x + centerX;
                    object.position.y = val.y + centerY;
                    object.position.z = 0;

                    scene.add(object);

                    /*val.label.split('').map((v, idx) => {

                        let geometry = new THREE.BoxGeometry(24, 64, 0);
                        geometry.name = val.label;//id
                        geometry.cname = val.name; //中文

                        var object = new THREE.Mesh(geometry, window.canvasTexture[v])//,new THREE.MeshBasicMaterial({ color:'rgba(255,255,255,0)' }))//, texture);

                        object.position.x = 12 + startX + idx * 24;
                        object.position.y = startY;
                        object.position.z = 0;

                        scene.add(object);
                    })*/


                    // end


                    // drawText(val, color);



                })
            }

        }

        function drawLine(adjacent) {

            let isDirect = showType === 'direct'
            let color = null, x = null, y = null;
            if (adjacent) {
                x = adjacent.x;
                y = adjacent.y;

            }
            datas.edges.map((val) => {
                color = '#666666';
                //选中点的直接连接线颜色 红色
                if (adjacent && (adjacent.label === val.w || adjacent.label === val.v)) {
                    camera.position.set(x + centerX, y + centerY, 4000);  //
                    controls.target.set(x + centerX, y + centerY, 0);

                    color = '#d73143'
                };
                var material = new THREE.LineBasicMaterial({
                    color,

                    linewidth: 5, // in pixels

                    //vertexColors: THREE.VertexColors,
                    //resolution:  // to be set by renderer, eventually
                    dashed: true
                });

                // var material = new THREE.LineDashedMaterial({
                //     color,
                //     scale: 2,
                //     dashSize: 4,
                //     gapSize: 20,
                //     linewidth: 5, // in pixels

                //     //vertexColors: THREE.VertexColors,
                //     //resolution:  // to be set by renderer, eventually
                //     // dashed: true
                // });
                // if (isDirect) {
                //     if (!(directNode.indexOf(val.v) > -1 || directNode.indexOf(val.w) > -1)) {
                //         return
                //     }
                //     console.log('eeee')
                // }

                let pos = val.points
                var geometry = new THREE.Geometry();
                geometry.lineInfo = val;
                pos.map((v) => {
                    geometry.vertices.push(new THREE.Vector3(v.x + centerX, v.y + centerY, 0));
                })


                let len = pos.length

                let source = {
                    position: {
                        x: pos[len - 2].x + centerX,
                        y: pos[len - 2].y + centerY,
                        z: 0
                    }
                }
                let target = {
                    position: {
                        x: pos[len - 1].x + centerX,
                        y: pos[len - 1].y + centerY,
                        z: 0
                    }
                }

                var direction = new THREE.Vector3();
                direction.subVectors(target.position, source.position)
                direction.normalize()
                var end = new THREE.Vector3(target.position.x, target.position.y, target.position.z)
                var start = new THREE.Vector3(source.position.x, source.position.y, source.position.z);
                var length = end.distanceTo(start);
                var arrowHelper = new THREE.ArrowHelper(direction, start, length, color, 16, 16);
                arrowHelper.arrowInfo = val;
                scene.add(arrowHelper)




                var line = new THREE.Line(geometry, material);
                // line.scale.set(2,2,2)
                scene.add(line);
            })



        }

        // function drawCenterBox() {
        //     var geometry = new THREE.BoxBufferGeometry(512 * 2, 512 * 2, 0);
        //     targetCenter = new THREE.Mesh(geometry, drawText({ width: 256, height: 64, label: '' }, 'red'))//new THREE.MeshLambertMaterial({ color: 'red',wireframe:true }));

        //     scene.add(targetCenter);
        //     console.log(targetCenter)

        // }
        function getPixelRatio(context) {
            var backingStore = context.backingStorePixelRatio ||
                context.webkitBackingStorePixelRatio ||
                context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio ||
                context.oBackingStorePixelRatio ||
                context.backingStorePixelRatio || 1;
            return (window.devicePixelRatio || 1) / backingStore;
        };

        function drawTextBorder(val, color = '#0adc8b') {
            // if(window.nodeMaterialCanvas){
            //     return window.nodeMaterialCanvas
            // }
            imageCanvas = imageCanvas.cloneNode(true);
            let context = imageCanvas.getContext("2d");
            // console.time('drawText')
            let text = val.label

            var ratio = 4//getPixelRatio(context);
            imageCanvas.width = val.width * ratio;
            imageCanvas.height = val.height * ratio;
            context.scale(ratio, ratio);

            context.fillStyle = color;
            context.textBaseline = "top";
            context.font = "48px Monaco"
            // context.strokeRect( 0, 0, 128, 128 );
            text.split('').map((t, i) => {
                context.fillText(t, 5 + i * 24, 5)
            })

            // context.strokeStyle = color;

            // context.strokeRect(0, 0, val.width, val.height);

            var textureCanvas = new THREE.CanvasTexture(imageCanvas).clone();



            var materialCanvas = new THREE.MeshBasicMaterial({ map: textureCanvas, color });
            //materialCanvas.scale.set(2,2,2)
            // console.timeEnd('drawText')
            return materialCanvas.clone();



        }

        function drawWord(val, color = '#0adc8b') {
            let ratio = 1;
            let word = 'abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            word.split('').map((v) => {


                let imageCanvas = document.createElement('canvas')

                imageCanvas.width = 24 * ratio;
                imageCanvas.height = 64 * ratio;
                let context = imageCanvas.getContext("2d");
                context.scale(ratio, ratio);

                context.fillStyle = color;
                context.textBaseline = "top";
                context.font = "48px serif"

                context.fillText(v, 1, 5)//, 5 + i * 24, 5)

                // context.strokeStyle = color;

                // context.strokeRect(0, 0, val.width, val.height);

                var textureCanvas = new THREE.CanvasTexture(imageCanvas);



                var materialCanvas = new THREE.MeshBasicMaterial({ map: textureCanvas });
                window.canvasTexture = window.canvasTexture || {};
                window.canvasTexture[v] = materialCanvas;
                //materialCanvas.scale.set(2,2,2)
                // console.timeEnd('drawText')
            })



        }


        function drawText(val, color) {
            var xMid, text;
            var matLite = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                //size:128,
                // opacity: 1,
                side: THREE.DoubleSide
            });
            var shapes = FONT.generateShapes(val.label, 32);

            var geometry = new THREE.ShapeGeometry(shapes);
            text = new THREE.Mesh(geometry, matLite);
            // text.position.z = - 150;
            text.position.set(val.x + centerX - val.width / 2, val.y + centerY - val.height / 4, 2)// = - 150;
            // object.position.x = val.x + centerX;
            // object.position.y = val.y + centerY;
            // object.position.z = 0;
            scene.add(text);


        }

        function addLabel(name, location, color) {

            var textGeo = new THREE.TextBufferGeometry(name, {

                font: FONT,

                size: 24,
                height: 1,
                // curveSegments: 1

            });

            var textMaterial = new THREE.MeshBasicMaterial({ color });
            var textMesh = new THREE.Mesh(textGeo, textMaterial);
            textMesh.position.set(location.x, location.y, 0);
            scene.add(textMesh);

        }
        function animate() {

            requestAnimationFrame(animate);

            render();
            // stats.update();

        }

        function render() {

            controls.update();
            // console.log(controls.target)
            // targetCenter.visible = false;
            renderer.render(scene, camera);

            // targetCenter.visible = true;
            // targetCenter.position.set(controls.target.x, controls.target.y, controls.target.z);
            // hawkRenderer.render(scene, camera1)



        }
        function rerender() {
            scene.children = [];
            centerX = datas.center.centerX;
            centerY = datas.center.centerY;
            drawLine();
            drawNode();
            camera.position.set(0, 0, 4000);  //
            controls.target.set(0, 0, 0);

            load.style.display = 'none';
            popClickBox.style.display = 'none';
            console.timeEnd('rerender')
        }



        var raycaster = new THREE.Raycaster();
        let INTERSECTED = null
        function onDocumentMove(event) {


            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {

                INTERSECTED = intersects[0].object;
                if (INTERSECTED.type === 'Mesh') {
                    let id = INTERSECTED.geometry.name
                    if (clickId === id) {
                        return;
                    }
                    let detail = lists[id];
                    if (!detail) {
                        return
                    }

                    let popHTML = `
                        <div>
                            <span>中文名：</span>
                            <span>${detail.cname}</span>
                        </div>
                        <div><span>表名：</span><span>${detail.name}</span></div>
                       
                        `
                    //     <div><span>创建人：</span><span>${detail.creator}</span></div>

                    //    <div><span>描述：</span><span>${detail.description}</span></div>
                    //    <div><span>上游节点：</span><span>${detail.ups}</span></div>
                    //    <div><span>下游节点：</span><span>${detail.downs}</span></div>
                    //    <div style="text-align:right">
                    //        <a style="color:#108ee9;font-size:12px">
                    //        ${ showType === 'direct' ? '可点击加载该节点的直接上下游数据！' : 'a.可双击切换视图到该节点上！<br/>b.单击显示该节点上下游关系！'}
                    //        </a></div>
                    popBox.innerHTML = popHTML;
                    popBox.style.display = "block";
                    let { clientWidth, clientHeight } = popBox;

                    popBox.style.top = `${event.clientY - clientHeight - 30}px`;
                    popBox.style.left = `${event.clientX - clientWidth / 2}px`


                }

            } else {

                INTERSECTED = null;
                popBox.style.display = "none";

            }



        }
        function onDocumentClick(event) {
            if (window._timer) {
                clearTimeout(window._timer);
                return;
            }

            window._timer = setTimeout(() => {
                window._timer = null;
                let isDirect = showType === 'direct';

                event.preventDefault();

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                var intersects = raycaster.intersectObjects(scene.children);

                if (intersects.length > 0) {

                    INTERSECTED = intersects[0].object;

                    if (INTERSECTED.type === 'Mesh') {
                        let id = INTERSECTED.geometry.name

                        //如果只展示上下游
                        if (isDirect) {
                            let i = directNode.indexOf(id)
                            i > -1 && directNode.splice(i, 1)

                            directNode.push(id)
                            // return getDirectNode()
                            // return rerender();


                        }
                        let getFn = isDirect ? `getDirectNode('${id}')` : `getNodesData('${id}')`
                        //如果在全部表中展示，则高亮
                        selectNode(id)

                        let detail = lists[id];
                        if (!detail) {
                            return
                        }
                        clickId = id;
                        let popHTML = `
                        <div>
                            <span>中文名：</span>
                            <span>${detail.cname}</span>
                        </div>
                        <div><span>表名：</span><span>${detail.name}</span></div>
                        <div><span>创建人：</span><span>${detail.creator}</span></div>
                       
                        <div><span>描述：</span><span>${detail.description}</span></div>
                        <div><span>上游节点：</span><span>${detail.ups}</span></div>
                        <div><span>下游节点：</span><span>${detail.downs}</span></div>
                        <div style="text-align:right">
                            <button 
                            style="padding: 4px;border-radius: 4px;background: #108ee9;color: #fff;border: none;" 
                            onclick=${getFn}>
                            查看该视图
                            </button>
                        </div>
                        `
                        popClickBox.innerHTML = popHTML;
                        popClickBox.style.display = "block";
                        popBox.style.display = "none";
                        let { clientWidth, clientHeight } = popClickBox;

                        popClickBox.style.top = `${event.clientY - clientHeight - 30}px`;
                        popClickBox.style.left = `${event.clientX - clientWidth / 2}px`

                    } else {
                        clickId = null;
                        popClickBox.style.display = "none"
                    }

                } else {
                    clickId = null;
                    INTERSECTED = null;
                    popClickBox.style.display = "none";
                }
            }, 50)



        }

        function onDocumentDbClick(event) {


            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {

                INTERSECTED = intersects[0].object;
                if (INTERSECTED.type === 'Mesh') {
                    let id = INTERSECTED.geometry.name

                    getNodesData(id);


                }

            }



        }

        function getNodesData(id) {
            load.style.display = 'flex';
            popClickBox.style.display = "none";
            setTimeout(() => {
                ajax('/rela?id=' + id, (data) => {
                    if (data.er) {
                        let isGetData = confirm('暂无数据，是否现在计算数据？\n\n注：数据较大时，需要等待较长时间')
                        isGetData && (getReladata(id))
                    } else {
                        window.datas = data.data


                    }
                })
                controls.reset();
                rerender();
            }, 50)
            // datas = getReladata(id)




        }


        function selectNode(id) {
            let adjacent = null;
            // adjacent = adjacent.concat(list[id].parents).concat(list[id].children)
            // datas.edgesId.map((val) => {
            //     if (val.source === id) {
            //         adjacent.push(val.target)
            //     } else if (val.target === id) {
            //         adjacent.push(val.source)
            //     }

            // })

            //选中节点的颜色


            let detail = list[id];
            let pNodeAndCnode = detail.children.concat(detail.parents);
            pNodeAndCnode.push(id);
            scene.children.map((val) => {

                //重置对应节点||高亮
                if (val.type === 'Mesh' && val.material.selected) {
                    let oldSelect = null;
                    val.material.selected = false;
                    datas.nodes.map((v) => {
                        if (v.label === val.geometry.name) {
                            oldSelect = v;
                        }
                    })
                    val.material = drawTextBorder(oldSelect, '#61f316')
                }
                // if (val.type === 'Mesh' && val.geometry.name === id) {
                if (val.type === 'Mesh' && val.geometry.name !== datas.main.label && pNodeAndCnode.indexOf(val.geometry.name) > -1) {
                    let adjacent = null;
                    datas.nodes.map((v) => {
                        if (v.label === val.geometry.name) {
                            adjacent = v;
                        }
                    })
                    val.material = drawTextBorder(adjacent, '#d73143');//
                    val.material.selected = true;
                }


                //重置对应线||高亮
                /* if (
                     val.type === "Line" && val.selected) {
                     val.selected = false;
                     val.material.color = new THREE.Color(0x999999)
 
                 }
                 if (
                     val.type === "Line"
                     && (val.geometry.lineInfo.w === id || val.geometry.lineInfo.v === id)
                 ) {
                     val.selected = true;
                     val.material.color = new THREE.Color(0xd73143)
 
                 }
 
                 //重置对应箭头||高亮
                 if (
                     val.arrowInfo && val.selected
                 ) {
                     val.selected = false;
                     val.children.forEach((v) => {
                         v.material.color = new THREE.Color(0x999999)
                     })
 
 
                 }
 
                 if (
                     val.arrowInfo
                     && (val.arrowInfo.w === id || val.arrowInfo.v === id)
                 ) {
                     val.selected = true;
                     val.children.forEach((v) => {
                         v.material.color = new THREE.Color(0xd73143)
                     })
 
 
                 }*/


            })

            //重绘相关线的颜色
            // scene.children = [];
            // drawNode(adjacent);
            // drawLine(adjacent);
        }



    </script>
</body>

</html>